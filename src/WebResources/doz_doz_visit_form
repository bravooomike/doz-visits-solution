var dozVisit = (function () {
    // ====== SCHEMATY (LOGICAL NAMES) ======
    // Visit
    const ATTR_STATUS = "doz_visit_status"; // Choice
    const ATTR_NOTES = "doz_notes"; // Text (multi-line)
    const ATTR_PHARMACY = "doz_pharmacy"; // Lookup → Pharmacy
    const ATTR_WITH_OWNER = "doz_visit_with_owner"; // Two Options
    const ATTR_VISIT_TYPE = "doz_pharmacy_type"; // Choice (na Visit)
    const ATTR_VISIT_DATE = "doz_visit_date"; // Date

    // Pharmacy table
    const TABLE_PHARMACY = "doz_pharmacy";
    const COL_PHARMACY_TYPE = "doz_pharmacy_type";

    // ====== WARTOŚCI CHOICE ======
    // Visit Status
    const STATUS_PLANNED = 778870000;
    const STATUS_COMPLETED = 778870001;
    const STATUS_CANCELLED = 778870002;
    const STATUS_NONE = 778870003; // „Brak statusu”

    // Pharmacy Type
    const TYPE_OWN = 778870000;
    const TYPE_FRANCHISE = 778870001;

    // ====== Helpers daty ======
    function startOfDay(d) {
        const x = new Date(d.getFullYear(), d.getMonth(), d.getDate());
        x.setHours(0, 0, 0, 0);
        return x;
    }
    function todayLocal() {
        const n = new Date();
        n.setHours(0, 0, 0, 0);
        return n;
    }

    // --------------------------------------------------------
    // NOTES: dozwolone *tylko* dla Completed/Cancelled
    //        - wtedy wymagane i edytowalne
    //        - w pozostałych przypadkach czyszczone i blokowane
    // --------------------------------------------------------
    function applyNotesRule(formCtx) {
        const statusAttr = formCtx.getAttribute(ATTR_STATUS);
        const notesAttr = formCtx.getAttribute(ATTR_NOTES);
        if (!statusAttr || !notesAttr) return;

        const v = statusAttr.getValue();
        const allowed = v === STATUS_COMPLETED || v === STATUS_CANCELLED;

        // wymagane tylko gdy dozwolone
        notesAttr.setRequiredLevel(allowed ? "required" : "none");

        // włącz/wyłącz WSZYSTKIE kontrolki związane z atrybutem "Notes"
        formCtx.ui.controls.forEach(function (c) {
            if (typeof c.getAttribute === "function") {
                const a = c.getAttribute();
                if (
                    a &&
                    a.getName &&
                    a.getName() === ATTR_NOTES &&
                    typeof c.setDisabled === "function"
                ) {
                    c.setDisabled(!allowed);
                }
            }
        });

        // jeśli niedozwolone – wyczyść wartość (żeby nie zostało nic "w tle")
        if (!allowed && notesAttr.getValue()) {
            notesAttr.setValue(null);
        }
    }

    // Dodatkowa strażka przy zapisie: Notes dozwolone tylko dla Completed/Cancelled
    function validateNotesVsStatus(formCtx) {
        const statusAttr = formCtx.getAttribute(ATTR_STATUS);
        const notesAttr = formCtx.getAttribute(ATTR_NOTES);
        if (!statusAttr || !notesAttr) return true;

        const v = statusAttr.getValue();
        const allowed = v === STATUS_COMPLETED || v === STATUS_CANCELLED;
        const hasText = !!(
            notesAttr.getValue() && String(notesAttr.getValue()).trim()
        );

        // oczyść ewentualne notyfikacje na wszystkich kontrolkach powiązanych z Notes
        formCtx.ui.controls.forEach(function (c) {
            if (typeof c.getAttribute === "function") {
                const a = c.getAttribute();
                if (
                    a &&
                    a.getName &&
                    a.getName() === ATTR_NOTES &&
                    typeof c.clearNotification === "function"
                ) {
                    c.clearNotification("doz_notes_forbidden");
                }
            }
        });

        if (!allowed && hasText) {
            const ctrl = formCtx.getControl(ATTR_NOTES);
            if (ctrl && ctrl.setNotification) {
                ctrl.setNotification(
                    "Notes can be entered only when the status is Completed or Cancelled.",
                    "doz_notes_forbidden"
                );
            }
            return false;
        }
        return true;
    }

    // --------------------------------------------------------
    // WITH OWNER: pokazuj/wymagaj tylko dla apteki typu Franchise
    // --------------------------------------------------------
    function setWithOwnerVisible(formCtx, visible, required) {
        const ctrl = formCtx.getControl(ATTR_WITH_OWNER);
        const attr = formCtx.getAttribute(ATTR_WITH_OWNER);
        if (ctrl) ctrl.setVisible(visible);
        if (attr) {
            attr.setRequiredLevel(required ? "required" : "none");
            if (!visible) attr.setValue(null);
        }
    }

    function evaluateWithOwnerRule(formCtx) {
        const pharmacyAttr = formCtx.getAttribute(ATTR_PHARMACY);
        if (!pharmacyAttr) return;

        const lookup = pharmacyAttr.getValue();
        if (!lookup || lookup.length === 0) {
            setWithOwnerVisible(formCtx, false, false);
            return;
        }

        const id = (lookup[0].id || "").replace(/[{}]/g, "");
        if (!id) {
            setWithOwnerVisible(formCtx, false, false);
            return;
        }

        Xrm.WebApi.retrieveRecord(
            TABLE_PHARMACY,
            id,
            `?$select=${COL_PHARMACY_TYPE}`
        )
            .then(function (res) {
                const typeVal = res[COL_PHARMACY_TYPE];
                if (typeVal === TYPE_FRANCHISE) {
                    setWithOwnerVisible(formCtx, true, true);
                } else {
                    setWithOwnerVisible(formCtx, false, false);
                }
            })
            .catch(function () {
                setWithOwnerVisible(formCtx, false, false);
            });
    }

    // --------------------------------------------------------
    // FILTROWANIE LOOKUPU PHARMACY po typie z VISIT + blokada
    // --------------------------------------------------------
    function wirePharmacyFilter(formCtx) {
        const ctrl = formCtx.getControl(ATTR_PHARMACY);
        if (!ctrl) return;

        ctrl.addPreSearch(function () {
            const typeAttr = formCtx.getAttribute(ATTR_VISIT_TYPE);
            const typeVal = typeAttr ? typeAttr.getValue() : null;
            if (typeVal == null) return;

            let filterXml = "<filter type='and'>";
            filterXml += `<condition attribute='${COL_PHARMACY_TYPE}' operator='eq' value='${typeVal}' />`;
            filterXml += "</filter>";

            ctrl.addCustomFilter(filterXml, TABLE_PHARMACY);
        });
    }

    function updatePharmacyEnable(formCtx) {
        const typeAttr = formCtx.getAttribute(ATTR_VISIT_TYPE);
        const pharmAttr = formCtx.getAttribute(ATTR_PHARMACY);
        const pharmCtrl = formCtx.getControl(ATTR_PHARMACY);
        if (!typeAttr || !pharmAttr || !pharmCtrl) return;

        const hasType = typeAttr.getValue() != null;
        pharmCtrl.setDisabled(!hasType);
        if (!hasType) pharmAttr.setValue(null);
    }

    // --------------------------------------------------------
    // Ukryj „No Status” w wyborze (jeśli nie jest aktualnie ustawiony)
    // --------------------------------------------------------
    function hideNoStatusChoiceWhenNotSelected(formCtx) {
        const attr = formCtx.getAttribute(ATTR_STATUS);
        const ctrl = formCtx.getControl(ATTR_STATUS);
        if (!attr || !ctrl) return;

        const current = attr.getValue();
        if (current !== STATUS_NONE) {
            try {
                ctrl.removeOption(STATUS_NONE);
            } catch (e) {
                /* already removed */
            }
        }
    }

    // --------------------------------------------------------
    // „po terminie” → ustaw automatycznie STATUS_NONE
    // (nie nadpisuje Completed/Cancelled)
    // --------------------------------------------------------
    function ensureNoStatusIfOverdue(formCtx) {
        const dateAttr = formCtx.getAttribute(ATTR_VISIT_DATE);
        const statusAttr = formCtx.getAttribute(ATTR_STATUS);
        if (!dateAttr || !statusAttr) return;

        const v = dateAttr.getValue();
        if (!v) return;

        const visitDay = startOfDay(v);
        const today = todayLocal();

        if (visitDay < today) {
            const cur = statusAttr.getValue();
            if (
                cur !== STATUS_COMPLETED &&
                cur !== STATUS_CANCELLED &&
                cur !== STATUS_NONE
            ) {
                statusAttr.setValue(STATUS_NONE);
            }
        }
    }

    // --------------------------------------------------------
    // wizyta nie może być ustawiana na datę < dziś
    // --------------------------------------------------------
    function validateDateNotInPast(formCtx) {
        const dateAttr = formCtx.getAttribute(ATTR_VISIT_DATE);
        const dateCtrl = formCtx.getControl(ATTR_VISIT_DATE);
        if (!dateAttr || !dateCtrl) return true;

        if (typeof dateCtrl.clearNotification === "function") {
            dateCtrl.clearNotification("doz_date_past");
        }

        const v = dateAttr.getValue();
        if (!v) return true;

        const isPast = startOfDay(v) < todayLocal();
        if (isPast) {
            if (typeof dateCtrl.setNotification === "function") {
                dateCtrl.setNotification(
                    "Visit date cannot be earlier than today.",
                    "doz_date_past"
                );
            }
            return false;
        }
        return true;
    }

    // --------------------------------------------------------
    // HANDLERY
    // --------------------------------------------------------
    function onLoad(executionContext) {
        const formCtx = executionContext.getFormContext();

        // 1) Data – najpierw ustaw „No Status” jeśli po terminie + walidacja daty
        if (formCtx.getAttribute(ATTR_VISIT_DATE)) {
            formCtx.getAttribute(ATTR_VISIT_DATE).addOnChange(onVisitDateChange);
            ensureNoStatusIfOverdue(formCtx);
            validateDateNotInPast(formCtx);
        }

        // 2) Status/Notes – po ewentualnym ustawieniu „No Status”
        if (formCtx.getAttribute(ATTR_STATUS)) {
            hideNoStatusChoiceWhenNotSelected(formCtx);
            applyNotesRule(formCtx);
            formCtx.getAttribute(ATTR_STATUS).addOnChange(onStatusChange);
        }

        // 3) With Owner
        if (formCtx.getAttribute(ATTR_PHARMACY)) {
            evaluateWithOwnerRule(formCtx);
            formCtx.getAttribute(ATTR_PHARMACY).addOnChange(onPharmacyChange);
        }

        // 4) Filtr Pharmacy wg typu + blokada gdy brak typu
        if (formCtx.getAttribute(ATTR_VISIT_TYPE)) {
            wirePharmacyFilter(formCtx);
            updatePharmacyEnable(formCtx);
            formCtx.getAttribute(ATTR_VISIT_TYPE).addOnChange(onVisitTypeChange);
        }

        // OnSave – walidacje
        formCtx.data.entity.addOnSave(onSave);
    }

    function onPharmacyChange(executionContext) {
        const formCtx = executionContext.getFormContext();
        evaluateWithOwnerRule(formCtx);
    }

    function onStatusChange(executionContext) {
        const formCtx = executionContext.getFormContext();
        applyNotesRule(formCtx);
        hideNoStatusChoiceWhenNotSelected(formCtx);
    }

    function onVisitTypeChange(executionContext) {
        const formCtx = executionContext.getFormContext();
        const pharmAttr = formCtx.getAttribute(ATTR_PHARMACY);
        if (pharmAttr) pharmAttr.setValue(null);
        updatePharmacyEnable(formCtx);
    }

    function onVisitDateChange(executionContext) {
        const formCtx = executionContext.getFormContext();
        if (validateDateNotInPast(formCtx)) {
            ensureNoStatusIfOverdue(formCtx);
            // po ewentualnym przestawieniu statusu – odśwież Notes i ukrywanie No Status
            applyNotesRule(formCtx);
            hideNoStatusChoiceWhenNotSelected(formCtx);
        }
    }

    function onSave(executionContext) {
        const formCtx = executionContext.getFormContext();
        const okDate = validateDateNotInPast(formCtx);
        const okNotes = validateNotesVsStatus(formCtx);
        if (!okDate || !okNotes) {
            executionContext.getEventArgs().preventDefault();
        } else {
            ensureNoStatusIfOverdue(formCtx);
        }
    }

    return {
        onLoad,
        onPharmacyChange,
        onStatusChange,
        onVisitTypeChange,
        onVisitDateChange,
        onSave,
    };
})();

